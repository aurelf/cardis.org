<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Introduction</TITLE>
<META NAME="description" CONTENT="Introduction">
<META NAME="keywords" CONTENT="paper">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"><script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(t,e,n){function r(n){if(!e[n]){var o=e[n]={exports:{}};t[n][0].call(o.exports,function(e){var o=t[n][1][e];return r(o?o:e)},o,o.exports)}return e[n].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<n.length;o++)r(n[o]);return r}({QJf3ax:[function(t,e){function n(t){function e(e,n,a){t&&t(e,n,a),a||(a={});for(var c=u(e),f=c.length,s=i(a,o,r),p=0;f>p;p++)c[p].apply(s,n);return s}function a(t,e){f[t]=u(t).concat(e)}function u(t){return f[t]||[]}function c(){return n(e)}var f={};return{on:a,emit:e,create:c,listeners:u,_events:f}}function r(){return{}}var o="nr@context",i=t("gos");e.exports=n()},{gos:"7eSDFh"}],ee:[function(t,e){e.exports=t("QJf3ax")},{}],gos:[function(t,e){e.exports=t("7eSDFh")},{}],"7eSDFh":[function(t,e){function n(t,e,n){if(r.call(t,e))return t[e];var o=n();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(t,e,{value:o,writable:!0,enumerable:!1}),o}catch(i){}return t[e]=o,o}var r=Object.prototype.hasOwnProperty;e.exports=n},{}],D5DuLP:[function(t,e){function n(t,e,n){return r.listeners(t).length?r.emit(t,e,n):(o[t]||(o[t]=[]),void o[t].push(e))}var r=t("ee").create(),o={};e.exports=n,n.ee=r,r.q=o},{ee:"QJf3ax"}],handle:[function(t,e){e.exports=t("D5DuLP")},{}],XL7HBI:[function(t,e){function n(t){var e=typeof t;return!t||"object"!==e&&"function"!==e?-1:t===window?0:i(t,o,function(){return r++})}var r=1,o="nr@id",i=t("gos");e.exports=n},{gos:"7eSDFh"}],id:[function(t,e){e.exports=t("XL7HBI")},{}],loader:[function(t,e){e.exports=t("G9z0Bl")},{}],G9z0Bl:[function(t,e){function n(){var t=l.info=NREUM.info;if(t&&t.agent&&t.licenseKey&&t.applicationID&&c&&c.body){l.proto="https"===p.split(":")[0]||t.sslForHttp?"https://":"http://",a("mark",["onload",i()]);var e=c.createElement("script");e.src=l.proto+t.agent,c.body.appendChild(e)}}function r(){"complete"===c.readyState&&o()}function o(){a("mark",["domContent",i()])}function i(){return(new Date).getTime()}var a=t("handle"),u=window,c=u.document,f="addEventListener",s="attachEvent",p=(""+location).split("?")[0],l=e.exports={offset:i(),origin:p,features:{}};c[f]?(c[f]("DOMContentLoaded",o,!1),u[f]("load",n,!1)):(c[s]("onreadystatechange",r),u[s]("onload",n)),a("mark",["firstbyte",i()])},{handle:"D5DuLP"}]},{},["G9z0Bl"]);</script>
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="paper.css">

<LINK REL="next" HREF="node2.html">
<LINK REL="previous" HREF="index.html">
<LINK REL="up" HREF="index.html">
<LINK REL="next" HREF="node2.html">
</HEAD>

<a href="http://www.usenix.org"><img src="../../../../../../graphics/new_usenix.jpg" width="288" height="232" alt="Check out the new USENIX Web site." align="right"></a>


<BODY >
<!--Navigation Panel-->
<A NAME="tex2html38"
  HREF="node2.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html36"
  HREF="index.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html30"
  HREF="index.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html39"
  HREF="node2.html">Constructing Method Call Graphs</A>
<B> Up:</B> <A NAME="tex2html37"
  HREF="index.html">Model Checking of Multi-Applet</A>
<B> Previous:</B> <A NAME="tex2html31"
  HREF="index.html">Model Checking of Multi-Applet</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00010000000000000000">
Introduction</A>
</H1>

<P>
Smart cards have come to play an ever increasing role
in our lives. 
We use them in electronic banking, 
to keep health care data, 
for mobile telephony, and in many other applications.
The most important aspect of smartcards is their security; 
users and card issuers have to agree that the level of
security provided by a smartcard platform
is enough to prevent malicious agents from 
abusing their trust in a card application.

<P>
Since the number of smartcard applications is growing rapidly,
it is natural to provide smartcards with the possibility of
accommodating multiple applications, and the possibility to
delete or add new applications after the card has been issued.
Furthermore, such multi-application smartcards allow partner 
applications to cooperate and exchange data. Popular 
applications of multi-application cards 
are partner loyalty programs, mobile telephone to banking 
partnership programs, etc. 
The JavaCard platform&nbsp;[<A
 HREF="node20.html#JavaCard211">12</A>] is one platform for
building such multi-application smartcards. It is based on
a subset of Java tailored to the task of embedding on a smartcard.
The current standard omits many
of the features of Java such as concurrency through threads,
garbage collection, and many API functions
but has a notion of applets to support multiple applications.

<P>
One important aspect which distinguishes multi-applet JavaCards 
from single-applet ones is the support for inter-applet communication
via method calls.
Communication naturally comes at a price:
applets must guard against illicit invocations of their public
methods from unwarranted applets, and from leakage
of data to third parties.
Even if a multi-applet application were to be proved
safe, there still exists the possibility of new unsafe applets
being loaded onto the card post-verification.
The JavaCard platform provides features to partially address these
security concerns.
Apart from a Java-style byte code verifier, which in the current
generation of JavaCard smartcards is typically located off-card,
there is a concept of a communication firewall that by default
prohibits applets from communicating with each other.
To enable communication to flow between applets, 
a recipient applet has to explicitly permit calls from the caller applet.

<P>
Such checks as above are static in nature, e.g., method calls
are always allowed, or they are never allowed.
The work reported here in contrast
permits to begin to characterise the temporal
restrictions of inter-applet communications.
In the formulation of such restrictions we consider a situation
when a set of applets have been loaded onto a smartcard, 
and formulate properties in Linear Temporal Logic (LTL)
regarding inter-applet communications
(in addition to properties about intra-applet method calls
and API usage).

<P>
To provide a semantic bridge between multi-applet programs 
and the temporal logic specification language, we use
the abstract notion of a program graph, capturing the control
flow of programs with procedures/methods, and which can be
efficiently computed. The behaviour of
such program graphs is defined through the notion of pushdown
systems, which provide a natural execution model for programs
with methods (and possibly recursion), and
for which completely automatic model checkers
for LTL exist.

<P>
In more detail the model checking proceeds as follows.
First the method call graphs of a set of JavaCard applets are obtained
using a Java byte code analysis tool&nbsp;[<A
 HREF="node20.html#jensen99verification">13</A>]
developed at INRIA Rennes, which we have adapted for JavaCard. 
The analysis is performed on a class basis. 
As a consequence individual
applet instances cannot be reasoned about;
correctness properties concern
activation of methods of classes extending
the JavaCard <TT>Applet</TT> class, rather than 
activation of methods of an applet instance.
Further details and limitations of this static analysis procedure
are discussed in Section&nbsp;<A HREF="node2.html#sect:rennes">2</A>.

<P>
The resulting method call graphs are translated into pushdown systems,
a natural execution model for programs with recursion. 
Essentially a pushdown system is a pair of a control location
with a stack of stack symbols. In our encoding
we use a single control location and let 
the stack symbols represent the program points
of the underlying JavaCard applets.
The details of the translation are elaborated
in Section&nbsp;<A HREF="node5.html#sect:to_pds">3.1</A>.

<P>
For pushdown systems the model checking procedure for
Linear Temporal Logic (LTL) is decidable
and of polynomial complexity in the size of the 
system&nbsp;[<A
 HREF="node20.html#bouajjani97reachability">3</A>,<A
 HREF="node20.html#finkeletal">9</A>,<A
 HREF="node20.html#esparza00efficient">7</A>].
The atomic predicates of the logic, tailored to JavaCard,
are the program points themselves and 
predicates expressing 
class and package membership of program points. 
The Moped model checker&nbsp;[<A
 HREF="node20.html#moped">8</A>] is used 
to check LTL properties of
pushdown systems.
Sections&nbsp;<A HREF="node6.html#sect:ltl">3.2</A>,<A HREF="node7.html#sect:specs">3.3</A> and&nbsp;<A HREF="node8.html#sect:moped">3.4</A> 
describes the logic
and our use of the Moped tool in further detail.

<P>
To motivate and demonstrate our approach we have
selected a prototypical JavaCard example:
a purse applet stores money, and interacts with loyalty applets
on receiving a purchase order.
A loyalty applet can have agreements with other applets,
and can thus in turn communicate with another applet on
receiving information about a purse transaction.
In Section&nbsp;<A HREF="node9.html#sect:example">4</A>
we demonstrate the effectiveness of our approach
in analysing such inter-applet communication patterns.

<P>
There exists by now a growing number of related work concerning
model checking Java (or JavaCard), 
or more general formal analysis of JavaCard applications;
below we will mention a few of them.

<P>
The Compaq Extended Static Checker for Java (ESC/Java)&nbsp;[<A
 HREF="node20.html#ESC">14</A>], 
developed at the 
Compaq Systems Research Center (SRC), is a programming tool for finding 
errors in Java programs. ESC/Java includes an annotation language with 
which programmers can express design decisions using light-weight 
specifications. Checking is neither sound nor complete, but can yield
informative warning messages<A NAME="tex2html2"
  HREF="footnode.html#foot741"><SUP>2</SUP></A>. 
A case study in the context of JavaCard, based on the Gemplus purse applet, 
is presented in&nbsp;[<A
 HREF="node20.html#Cat-Hui-02">5</A>].

<P>
The first version of the Java PathFinder&nbsp;[<A
 HREF="node20.html#havelund00model">10</A>], JPF, 
was a translator from a subset of Java 1.0 to 
PROMELA, the programming language of the Spin model checker. 
A similar translator tool from Java to PROMELA (actually the variant
of PROMELA for the dSpin tool)
is reported in&nbsp;[<A
 HREF="node20.html#iosif98modeling">11</A>].
The Java Pathfinder tool 
is especially suited for analyzing multi-threaded 
Java applications, 
where normal testing usually falls short. The tool can find deadlocks 
and violations of boolean assertions stated by the programmer in a special 
assertion language. A second version of the tool
reportedly works directly on bytecode and has support for garbage 
collection<A NAME="tex2html3"
  HREF="footnode.html#foot742"><SUP>3</SUP></A>.

<P>
The Bandera Project&nbsp;[<A
 HREF="node20.html#corbett00bandera">6</A>] 
aims to develop techniques and tools for automated 
reasoning about Java based
software system behavior, and to apply these tools to 
construct high-confidence mission-critical software. Automated reasoning 
is achieved by (1) mechanically creating high-level models of software 
systems using abstract interpretation and partial evaluation technologies, 
and then (2) employing model-checking techniques to automatically verify 
that software specifications are satisfied by the 
model<A NAME="tex2html4"
  HREF="footnode.html#foot743"><SUP>4</SUP></A>.

<P>
In&nbsp;[<A
 HREF="node20.html#bieber00checking">2</A>] an approach is presented for checking
properties of multi-applet interactions of JavaCards based
on associating security levels to applets and applet data,
and to thus detect illegal flow of information between applets.
Technically the approach requires building abstract models by
hand from byte code, and then to check them automatically using 
the SMV model checker.

<P>
Our work is related to the program verification approach 
of&nbsp;[<A
 HREF="node20.html#jensen99verification">13</A>] which is based on method call graphs. 
The operational semantics of the graphs, however, is given there directly 
through a set of transition rules (rather than through pushdown systems), 
and security properties are expressed as call-stack invariants. 
Following a similar program representation, a compositional 
account is given in&nbsp;[<A
 HREF="node20.html#Bar-Gur-Hui-02">1</A>], where a compositional proof 
system for inferring temporal properties of a multi-applet program from 
the properties of the individual applets is presented.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html38"
  HREF="node2.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html36"
  HREF="index.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html30"
  HREF="index.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html39"
  HREF="node2.html">Constructing Method Call Graphs</A>
<B> Up:</B> <A NAME="tex2html37"
  HREF="index.html">Model Checking of Multi-Applet</A>
<B> Previous:</B> <A NAME="tex2html31"
  HREF="index.html">Model Checking of Multi-Applet</A>
<!--End of Navigation Panel-->
<ADDRESS>
Lars-Ake Fredlund
2002-09-23
</ADDRESS>
<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"beacon-1.newrelic.com","licenseKey":"d823139095","applicationID":"509444","transactionName":"YVJVZksCXkEEVhIMWFgYdlFNCl9cSkAVAFlfT2hAXAdZQABWEhZoWFhDbV8MRVwB","queueTime":0,"applicationTime":86,"ttGuid":"","agentToken":"","atts":"TRVWEAMYTU8=","errorBeacon":"bam.nr-data.net","agent":"js-agent.newrelic.com\/nr-476.min.js"}</script></BODY>
</HTML>
